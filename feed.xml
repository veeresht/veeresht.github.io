<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://veeresht.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://veeresht.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-12-27T20:12:23+00:00</updated><id>https://veeresht.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Multipath Fading Channels and 3GPP-LTE Design</title><link href="https://veeresht.github.io/blog/2012/multipath-fading-channels-and-3gpp-lte-design/" rel="alternate" type="text/html" title="Multipath Fading Channels and 3GPP-LTE Design"/><published>2012-04-08T15:00:00+00:00</published><updated>2012-04-08T15:00:00+00:00</updated><id>https://veeresht.github.io/blog/2012/multipath-fading-channels-and-3gpp-lte-design</id><content type="html" xml:base="https://veeresht.github.io/blog/2012/multipath-fading-channels-and-3gpp-lte-design/"><![CDATA[<p>This article attempts to explain the rationale behind choosing particular parameter values in the design of the 3GPP-LTE standard using the concepts related to the effects of multipath fading channels in wireless communications.</p> <p>Multipath fading channels are often defined by four key parameters in the theory of wireless communications. These are the Delay Spread (\(T_d\)) and the Coherence Bandwidth (\(W_c\)) defining the multipath characteristics of the wireless channel; the Doppler Spread (\(D_s\)) and the Coherence Time (\(T_c\)) defining the fading characteristics of the wireless channel. [1] presents an excellent treatment of these concepts.</p> <p>The 3GPP-LTE standard specification [2] defines the system parameters for the OFDMA based physical layer downlink signal. Considering a system of bandwidth 10 MHz, other parameters defined are as follows:</p> <p>Sampling Rate: 15.36 MHz<br/> FFT Size: 1024<br/> Sub-carrier Spacing: 15 KHz<br/> Normal mode CP Length: 72 (4.6875 \(\mu\)s)<br/> Duration of one OFDM symbol: ≈ 71.3541 \(\mu\)s<br/> Frequency domain spacing between reference symbol sub-carriers: 6 (\(\Delta W\) = 0.09 MHz)<br/> Time domain spacing between reference OFDM symbols: 3 or 4; for this analysis, choose 4 (\(\Delta T\) ≈ 285.42 \(\mu\)s)</p> <p>The 3GPP-LTE standard specification [3] defines multipath fading channel models to be used in the design and evaluation of an LTE system. For our analysis, let us choose the Extended Typical Urban model (ETU) which has the highest worst case delay spread of \(T_d = 5000 ns\) among the models defined. The maximum doppler frequency for the ETU300Hz model is 300 Hz.</p> <p>Therefore, the coherence bandwidth \(W_c\) is given by [1] \(W_c = 12 T_d = 0.1\)MHz. Comparing this with \(\Delta W\) as defined above, we have \(\Delta W &lt; W_c\), that is the spacing of the reference sub-carriers in the frequency domain is less than the coherence bandwidth of the channel and hence we can assume a flat fading channel characteristic for all the sub-carriers between the reference sub-carriers. This implies that the channel estimates obtained using the known reference sub-carriers can also be used for equalization of the other sub-carriers.</p> <p>The ISI due to the multipath components of the channel is compensated by the cyclic prefix (CP) and we see that the the CP length in the normal mode (4.6875 \(\mu\)s) is slightly less than the worst case delay spread (5 \(\mu\)s). However LTE also supports an extended mode of CP where the length of the CP is 16.67 \(\mu\)s and this is sufficient to handle the worst case delay spread.</p> <p>The doppler spread of the channel model is calculated from the maximum doppler frequency as \(D_s = 300 Hz - (- 300 Hz) = 600 Hz\). Therefore, the coherence time \(T_c\) is given by [1]</p> \[T_c = \frac{1}{4 D_s} \approx 416.67 \mu s\] <p>Comparing this with \(\Delta T\) as defined above, we have \(\Delta T &lt; T_c\), that is the spacing of the reference symbols in time domain is less than the coherence time of the channel and hence we can assume that the channel does not change during the time interval corresponding to \(\Delta T\). This implies that the channel estimates obtained using the known reference symbols can also be used for equalization of the other non-reference OFDM symbols.</p> <p>References</p> <p>[1]. Tse, D and Viswanath, P. The wireless channel, In: Fundamentals of Wireless Communication. Cambridge University Press, 2005, 10 - 48.</p> <p>[2]. 3GPP TS 36.211. Evolved Universal Terrestrial Radio Access (E-UTRA); Physical channels and modulation.</p> <p>[3]. 3GPP TS 36.101. Evolved Universal Terrestrial Radio Access (E-UTRA); User Equipment (UE) radio transmission and reception.</p>]]></content><author><name></name></author><category term="communication-systems"/><category term="multipath-fading"/><category term="3gpp-lte"/><summary type="html"><![CDATA[Exploring parameter value choices in 3GPP-LTE design with respect to effects of multipath fading.]]></summary></entry><entry><title type="html">Carrier Frequency Offset in Single Carrier and OFDM Systems</title><link href="https://veeresht.github.io/blog/2012/carrier-frequency-offset-ofdm/" rel="alternate" type="text/html" title="Carrier Frequency Offset in Single Carrier and OFDM Systems"/><published>2012-04-02T15:00:00+00:00</published><updated>2012-04-02T15:00:00+00:00</updated><id>https://veeresht.github.io/blog/2012/carrier-frequency-offset-ofdm</id><content type="html" xml:base="https://veeresht.github.io/blog/2012/carrier-frequency-offset-ofdm/"><![CDATA[<p>Carrier Frequency Offset (CFO) is one of the most common impairments found in a communication system. As the name suggests, it is due to the mismatch between the carrier frequencies used by the transmitter and the receiver. The effects produced by CFO on single carrier and OFDM systems is very different. To illustrate this, a simple simulation of a 64-QAM based single carrier and OFDM system using CommPy is shown below.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">numpy</span> <span class="kn">import</span> <span class="n">real</span><span class="p">,</span> <span class="n">imag</span><span class="p">,</span> <span class="n">arange</span>
<span class="kn">from</span> <span class="n">numpy.fft</span> <span class="kn">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">ifft</span>
<span class="kn">from</span> <span class="n">numpy.random</span> <span class="kn">import</span> <span class="n">randint</span>
<span class="kn">from</span> <span class="n">commpy.modulation</span> <span class="kn">import</span> <span class="n">QAMModem</span>
<span class="kn">from</span> <span class="n">commpy.impairments</span> <span class="kn">import</span> <span class="n">add_frequency_offset</span>
<span class="kn">import</span> <span class="n">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="c1"># System Parameters 
# Sampling Frequency (Hz)
</span><span class="n">Fs</span> <span class="o">=</span> <span class="mf">15.36e6</span> 
<span class="c1"># Frequency Offset (Hz)
</span><span class="n">delta_f</span> <span class="o">=</span> <span class="mi">500</span>
<span class="c1"># FFT Size for OFDM 
</span><span class="n">N</span> <span class="o">=</span> <span class="mi">1024</span>

<span class="c1"># Generate message bits
</span><span class="n">msg_bits</span> <span class="o">=</span> <span class="nf">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6144</span><span class="p">)</span>
<span class="c1"># 64-QAM Modulation of the message bits
</span><span class="n">qam64</span> <span class="o">=</span> <span class="nc">QAMModem</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
<span class="n">tx_sc_symbols</span> <span class="o">=</span> <span class="n">qam64</span><span class="p">.</span><span class="nf">modulate</span><span class="p">(</span><span class="n">msg_bits</span><span class="p">)</span>
<span class="c1"># Add Frequency offset to the modulated symbols
</span><span class="n">rx_sc_symbols</span> <span class="o">=</span> <span class="nf">add_frequency_offset</span><span class="p">(</span><span class="n">tx_sc_symbols</span><span class="p">,</span> <span class="n">Fs</span><span class="p">,</span> <span class="n">delta_f</span><span class="p">)</span>

<span class="c1"># Ideal 64-QAM constellation
</span><span class="n">plt</span><span class="p">.</span><span class="nf">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="nf">real</span><span class="p">(</span><span class="n">tx_sc_symbols</span><span class="p">),</span> <span class="nf">imag</span><span class="p">(</span><span class="n">tx_sc_symbols</span><span class="p">),</span> <span class="sh">'</span><span class="s">.b</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlabel</span><span class="p">(</span><span class="sh">'</span><span class="s">I-component</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">ylabel</span><span class="p">(</span><span class="sh">'</span><span class="s">Q-component</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xticks</span><span class="p">(</span><span class="nf">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">yticks</span><span class="p">(</span><span class="nf">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlim</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># 64-QAM constellation for Single Carrier with Frequency offset
</span><span class="n">plt</span><span class="p">.</span><span class="nf">figure</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="nf">real</span><span class="p">(</span><span class="n">rx_sc_symbols</span><span class="p">),</span> <span class="nf">imag</span><span class="p">(</span><span class="n">rx_sc_symbols</span><span class="p">),</span> <span class="sh">'</span><span class="s">.b</span><span class="sh">'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlabel</span><span class="p">(</span><span class="sh">'</span><span class="s">I-component</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">ylabel</span><span class="p">(</span><span class="sh">'</span><span class="s">Q-component</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xticks</span><span class="p">(</span><span class="nf">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">yticks</span><span class="p">(</span><span class="nf">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlim</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># Generate OFDM signal (single symbol) using modulated symbols
</span><span class="n">tx_ofdm_waveform</span> <span class="o">=</span> <span class="nf">ifft</span><span class="p">(</span><span class="n">tx_sc_symbols</span><span class="p">)</span>
<span class="c1"># Add frequency offset to the OFDM signal
</span><span class="n">rx_ofdm_waveform</span> <span class="o">=</span> <span class="nf">add_frequency_offset</span><span class="p">(</span><span class="n">tx_ofdm_waveform</span><span class="p">,</span> <span class="n">Fs</span><span class="p">,</span> <span class="n">delta_f</span><span class="p">)</span>
<span class="c1"># OFDM Demodulation to extract the 64-QAM symbols
</span><span class="n">rx_ofdm_symbols</span> <span class="o">=</span> <span class="nf">fft</span><span class="p">(</span><span class="n">rx_ofdm_waveform</span><span class="p">)</span>

<span class="c1"># 64-QAM Constellation for OFDM with Frequency offset
</span><span class="n">plt</span><span class="p">.</span><span class="nf">figure</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="nf">real</span><span class="p">(</span><span class="n">rx_ofdm_symbols</span><span class="p">),</span> <span class="nf">imag</span><span class="p">(</span><span class="n">rx_ofdm_symbols</span><span class="p">),</span> <span class="sh">'</span><span class="s">.b</span><span class="sh">'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlabel</span><span class="p">(</span><span class="sh">'</span><span class="s">I-component</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">ylabel</span><span class="p">(</span><span class="sh">'</span><span class="s">Q-component</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xticks</span><span class="p">(</span><span class="nf">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">yticks</span><span class="p">(</span><span class="nf">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlim</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>

<span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>
</code></pre></div></div> <p>We have to look at the received IQ symbols to study the effect of frequency offset. Shown below are the IQ-constellations generated during the simulation.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/ideal-480.webp 480w,/assets/img/ideal-800.webp 800w,/assets/img/ideal-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/ideal.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> <figcaption class="caption">Ideal Constellation without Carrier Frequency Offset</figcaption> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/SC_with_offset-480.webp 480w,/assets/img/SC_with_offset-800.webp 800w,/assets/img/SC_with_offset-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/SC_with_offset.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> <figcaption class="caption">Single Carrier Constellation with Carrier Frequency Offset</figcaption> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/OFDM_with_offset-480.webp 480w,/assets/img/OFDM_with_offset-800.webp 800w,/assets/img/OFDM_with_offset-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/OFDM_with_offset.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> <figcaption class="caption">OFDM Constellation with Carrier Frequency Offset</figcaption> </figure> <p>As seen from the figures above, the constellation points are rotated by varying amounts in the case of a single carrier system whereas, in the case of an OFDM system the constellation points appear noisy. To answer the question of why this difference in the received constellation, we can do a mathematical analysis of the both the systems as follows.</p> <h3 id="assumptions-and-parameters">Assumptions and Parameters</h3> <p>Ideal System with frequency offset as the only impairment<br/> Modulation Scheme : 64-QAM<br/> Sampling Frequency (\(F_s\)) : 15.36 MHz<br/> FFT Size in OFDM : 1024 subcarriers<br/> Number of Bits : 6144 (equivalent to 1024 64-QAM symbols)</p> <h3 id="single-carrier-system">Single Carrier System</h3> <p>Let us denote, the 64-QAM modulated IQ symbols at the transmitter by \(x(n)\), the 64-QAM modulated IQ symbols at the receiver by \(r(n)\), the frequency offset (in Hz) introduced by \(\Delta f\), the sampling frequency (in Hz) of the system by \(F_s\).</p> <p>The relationship between \(r(n)\) and \(x(n)\) is expressed as \(r(n)=x(n) e^{j2\pi \Delta f n F_s}\) This can be further modified as</p> \[r(n)=A(n)e^{j\theta(n)}e^{j2\pi \Delta fn F_s}\] \[r(n)=A(n)e^{j(\theta(n)+j2\pi \Delta f n F_s)}\] <p>where \(A(n)\) and \(\theta(n)\) are the magnitude and the phase of the symbol \(x(n)\) respectively. From these equations, it is clear that the frequency offset introduces varying amounts of phase offset depending on the time instant n of the modulated symbol \(x(n)\). This explains the varying rotation of the received constellation points observed in Figure 2.</p> <h3 id="ofdm-system">OFDM System</h3> <p>Let us denote, the 64-QAM modulated IQ symbols at the transmitter by \(X(k)\), the OFDM signal at the transmitter by \(x(n)\), the OFDM signal at the receiver by \(r(n)\), the 64-QAM modulated IQ symbols at the receiver by \(R(k)\), the frequency offset (in Hz) introduced by \(\Delta f\),the sampling frequency (in Hz) of the system by \(F_{s}\), the sub-carrier spacing (in Hz) of the system by \(\Delta f_c\), the number of subcarriers (size of the DFT/IDFT) by \(N\).</p> <p>The OFDM signal is generated from the modulated symbols using a inverse Discrete Fourier Transform (IDFT) and is given by</p> \[x(n) = \sum_{n=0}^{N-1} X(k)e^{j2\pi k n N}\] <p>The relationship between \(r(n)\) and \(x(n)\) is expressed as</p> \[r(n) = x(n)e^{j2\pi\Delta f n F_s}\] <p>From the modulation property of the DFT and noting that \(\Delta f_c = \frac{F_s}{N}\), we can express the received 64-QAM modulated symbols as</p> \[R(k) = X\bigg(k−\frac{\Delta f}{\Delta f_c}\bigg)\] <p>Thus the effect of the frequency offset is a change in the sampling instants of the modulated symbols. To express \(R(k)\) in terms of \(X(k)\), we invoke the Sampling theorem as follows. The continuous time representation \(x(t)\) is given by,</p> \[x(t) = \sum_{k=-\infty}^{\infty} X(k) \frac{sin(\pi (2Wt−k))}{\pi (2Wt−k)}\] <p>where \(W\) represents the baseband bandwidth of the signal. Therefore, \(R(m)\) is given by</p> \[R(m) = X\bigg(m−\frac{\Delta f}{\Delta f_c}\bigg)\] \[R(m) = \sum_{k=-\infty}^{\infty} X(k)\frac{sin(\pi(\frac{2W}{F_s} (m−\frac{\Delta f}{\Delta f_c})−k))}{\pi(\frac{2W}{F_s} (m−\frac{\Delta f}{\Delta f_c})−k)}\] <p>Assuming \(F_s = 2W\) to simplify the equation we have,</p> \[R(m) = \sum_{k=-\infty}^{\infty} X(k)\frac{sin(\pi (m−\frac{\Delta f}{\Delta f_c}−k))}{\pi(m−\frac{\Delta f}{\Delta f_c}−k)}\] <p>This equation shows us that every received IQ symbol is the sum of scaled versions of all the transmitted IQ symbols, the scaling factor depends on \(m\), \(k\) and the ratio \(\frac{\Delta f}{\Delta f_c}\).</p> <p>The key point to note is that every IQ symbol (subcarrier) \(X(k)\) is a random variable (assuming the data is random) and hence the received IQ symbol \(R(m)\) is a sum of random variables which tends to a Gaussian random variable (by the Central Limit Theorem). This explains the observation in Figure 3, where the IQ constellation points appear to be affected by random noise. Since all the subcarriers interfere with the current subcarrier due to the CFO (loss of orthogonality), the effect of CFO on OFDM systems is commonly known by the term Inter-Carrier Interference (ICI).</p>]]></content><author><name></name></author><category term="communication-systems"/><category term="carrier-frequency-offset"/><category term="ofdm"/><summary type="html"><![CDATA[Observable effects of carrier frequency offset in OFDM systems v/s single carrier systems.]]></summary></entry><entry><title type="html">The Viterbi Algorithm - Illustrated!</title><link href="https://veeresht.github.io/blog/2012/viterbi-algorithm-illustrated/" rel="alternate" type="text/html" title="The Viterbi Algorithm - Illustrated!"/><published>2012-03-27T15:00:00+00:00</published><updated>2012-03-27T15:00:00+00:00</updated><id>https://veeresht.github.io/blog/2012/viterbi-algorithm-illustrated</id><content type="html" xml:base="https://veeresht.github.io/blog/2012/viterbi-algorithm-illustrated/"><![CDATA[<p>It is often helpful to visualize the operation of the Viterbi Algorithm used in the decoding of convolutional codes. Here is an attempt to do the same using Python, Matplotlib, NumPy, SciPy and CommPy.</p> <p>Below is a video which shows one such illustration of the Viterbi Algorithm in action using the following parameters.</p> <p>The convolutional code is represented by the encoder matrix,</p> \[G(D)=[1+D^2, 1+D+D^2]\] <p>Let us assume that the transmitted message is [1, 0, 0, 0] and hence the corresponding codeword is [11, 01, 11, 00]. Also assume that there was a single bit error during the transmission and therefore, let the received codeword be [11, 11, 11, 00]. The Viterbi algorithm operates on this received codeword and recovers the correct codeword [11, 01, 11, 00] as shown below.</p> <figure> <iframe src="https://www.youtube.com/embed/RqpXrw1d19E" class="img-fluid rounded z-depth-1" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="" width="auto" height="auto"/> </figure> <p>This animation was generated using Python code. The code along with this example can be found <a href="https://github.com/veeresht/viterbi-algorithm-animation">here</a>.</p>]]></content><author><name></name></author><category term="communication-systems"/><category term="viterbi-algorithm"/><category term="trellis-diagram"/><category term="commpy"/><category term="python"/><category term="matplotlib"/><summary type="html"><![CDATA[Example for generating trellis diagram plots with CommPy.]]></summary></entry><entry><title type="html">Plotting Trellis Diagrams with CommPy in Python</title><link href="https://veeresht.github.io/blog/2012/plotting-trellis-diagrams-commpy/" rel="alternate" type="text/html" title="Plotting Trellis Diagrams with CommPy in Python"/><published>2012-03-20T15:00:00+00:00</published><updated>2012-03-20T15:00:00+00:00</updated><id>https://veeresht.github.io/blog/2012/plotting-trellis-diagrams-commpy</id><content type="html" xml:base="https://veeresht.github.io/blog/2012/plotting-trellis-diagrams-commpy/"><![CDATA[<p>A trellis diagram is a representation of a convolutional code. During the study of convolutional and turbo codes, one often encounters situations where we would like to visualize the trellis diagram representation of a simple 4-state or an 8-state convolutional code.</p> <p>CommPy is an open source toolkit implementing digital communication algorithms in Python using NumPy,SciPy, Matplotlib and Cython. The visualize function in CommPy’s Trellis class is an attempt to make plotting trellis diagrams easy and simple. Here’s how to use it.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">numpy</span> <span class="kn">import</span> <span class="n">array</span>
<span class="kn">from</span> <span class="n">commpy.channelcoding</span> <span class="kn">import</span> <span class="n">Trellis</span>

<span class="c1"># Define the number of memory elements 
# per input in the convolutional encoder
</span><span class="n">memory</span> <span class="o">=</span> <span class="nf">array</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>

<span class="c1"># Define the generator matrix of 
# the convolutional encoder 
# Entries are in octal format
</span><span class="n">g_matrix</span> <span class="o">=</span> <span class="nf">array</span><span class="p">([[</span><span class="mi">05</span><span class="p">,</span> <span class="mi">07</span><span class="p">]])</span>

<span class="c1"># Create a trellis representation 
# from the encoder generator matrix 
</span><span class="n">trellis</span> <span class="o">=</span> <span class="nc">Trellis</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="n">g_matrix</span><span class="p">)</span>

<span class="c1"># Specify the number of time steps 
# in the trellis diagram
</span><span class="n">trellis_length</span> <span class="o">=</span> <span class="mi">3</span>

<span class="c1"># Specify the order in which states 
# should appear on the trellis diagram
</span><span class="n">state_order</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

<span class="c1"># Specify the colors for 0, 1 inputs
# '#FF0000' --&gt; Red   (edge corresponding to input 0)
# '#00FF00' --&gt; Green (edge corresponding to input 1)
</span><span class="n">bit_colors</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">#FF0000</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">#00FF00</span><span class="sh">'</span><span class="p">]</span> 

<span class="c1"># Plot the trellis diagram
</span><span class="n">trellis</span><span class="p">.</span><span class="nf">visualize</span><span class="p">(</span><span class="n">trellis_length</span><span class="p">,</span> <span class="n">state_order</span><span class="p">,</span> 
                  <span class="n">edge_colors</span> <span class="o">=</span> <span class="n">bit_colors</span><span class="p">)</span>
</code></pre></div></div> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/4_trellis-480.webp 480w,/assets/img/4_trellis-800.webp 800w,/assets/img/4_trellis-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/4_trellis.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> <figcaption class="caption">A 4-state trellis diagram</figcaption> </figure> <p>The snippet of code above and the trellis diagram correspond to the convolutional code generated using the encoder matrix,</p> \[G(D)=[1+D^2,1+D+D^2]\] <p>The polynomial entries correspond to the octal representations 101 (05) and 111 (07). The input/output labels are shown along with the states for the first stage of the trellis and the edge colors depict the output.</p> <p>Shown below is another trellis diagram representation of the encoder matrix</p> \[G(D)=[1+D^2+D^3,1+D+D^2+D^3]\] <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/8_trellis-480.webp 480w,/assets/img/8_trellis-800.webp 800w,/assets/img/8_trellis-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/8_trellis.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> <figcaption class="caption">An 8-state trellis diagram</figcaption> </figure>]]></content><author><name></name></author><category term="communication-systems"/><category term="trellis-diagram"/><category term="commpy"/><category term="python"/><summary type="html"><![CDATA[Example for generating trellis diagram plots with CommPy.]]></summary></entry></feed>